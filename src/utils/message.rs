use serde::{Deserialize, Serialize};

use super::get_current_time_nanos;

/// Creates a Waku message with the given message and content topic.
pub fn create_message(message: String, content_topic: String) -> Message {
    Message {
        payload: message,
        content_topic,
        version: 0,
        timestamp: get_current_time_nanos(),
        ephemeral: false,
    }
}

/// A Waku message, as defined by [14/WAKU2-MESSAGE](https://github.com/vacp2p/rfc-index/blob/main/waku/standards/core/14/message.md).
#[derive(Serialize, Deserialize, Debug)]
pub struct Message {
    /// The message payload as a base64 (with padding) encoded data string.
    payload: String,
    /// Message content topic for optional content-based filtering.
    content_topic: String,
    /// Message version. Used to indicate type of payload encryption. Default version is 0 (no payload encryption).
    version: u8,
    /// The time at which the message is generated by its sender. This field holds the Unix epoch time in nanoseconds as a 64-bits integer value.
    timestamp: u128,
    /// This flag indicates the transient nature of the message. Indicates if the message is eligible to be stored by the STORE protocol.
    ephemeral: bool,
    // meta: Option<Vec<u8>>, // TODO: metadata?
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_message() {
        let message = "Hello, world!".to_string();
        let content_topic = "/waku/0/default-waku/proto".to_string();
        let msg = create_message(message, content_topic);
        assert_eq!(msg.payload, "Hello, world!");
        assert_eq!(msg.content_topic, "/waku/0/default-waku/proto");
        assert_eq!(msg.version, 0);
        assert!(msg.timestamp > 0);
        assert_eq!(msg.ephemeral, true);
    }
}
