use crate::{
    config::constants::{WAKU_APP_NAME, WAKU_ENCODING, WAKU_ENC_VERSION},
    utils::{crypto::sha256hash, get_current_time_nanos},
};

use base64::{prelude::BASE64_STANDARD, Engine};
use ecies::PublicKey;
use serde::{de::Error, Deserialize, Serialize};

/// A Waku message, as defined by [14/WAKU2-MESSAGE](https://github.com/vacp2p/rfc-index/blob/main/waku/standards/core/14/message.md).
///
/// ## Fields
///
/// - `payload`: The message payload as a base64 encoded data string.
/// - `content_topic`: The message content topic for optional content-based filtering.
/// - `version`: Message version. Used to indicate type of payload encryption. Default version is 0 (no payload encryption).
/// - `timestamp`: The time at which the message is generated by its sender. This field holds the Unix epoch time in nanoseconds as a 64-bits integer value.
/// - `ephemeral`: This flag indicates the transient nature of the message. Indicates if the message is eligible to be stored by the STORE protocol.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct WakuMessage {
    pub payload: String,
    pub content_topic: String,
    #[serde(default)]
    version: u8,
    #[serde(default)]
    timestamp: u128,
    #[serde(default)]
    ephemeral: bool,
}

impl WakuMessage {
    /// Creates a new Waku message.
    ///
    /// ## Parameters
    /// - `payload` is gives as bytes. It is base64 encoded internally.
    /// - `topic` is the name of the topic itself within the full content topic. The rest of the content topic
    /// is filled in automatically, e.g. `/dria/0/<topic>/proto`.
    pub fn new(payload: impl AsRef<[u8]>, topic: &str) -> Self {
        WakuMessage {
            payload: BASE64_STANDARD.encode(payload),
            content_topic: Self::create_content_topic(topic),
            version: WAKU_ENC_VERSION,
            timestamp: get_current_time_nanos(),
            ephemeral: false,
        }
    }

    /// Decodes the base64 payload into bytes.
    pub fn decode_payload(&self) -> Result<Vec<u8>, base64::DecodeError> {
        BASE64_STANDARD.decode(&self.payload)
    }

    /// Decodes and parses the payload into JSON.
    pub fn parse_payload<T: for<'a> Deserialize<'a>>(&self) -> Result<T, serde_json::Error> {
        let payload = self
            .decode_payload()
            .map_err(|err| serde_json::Error::custom(format!("Base64 decode failed: {}", err)))?;

        serde_json::from_slice(&payload)
    }

    pub fn is_signed(&self, public_key: &PublicKey) -> Result<bool, serde_json::Error> {
        // decode base64 payload
        let payload = self
            .decode_payload()
            .map_err(|err| serde_json::Error::custom(format!("Base64 decode failed: {}", err)))?;

        // parse signature (64 bytes = 128 hex chars, although the full 65-byte RSV signature is given)
        let signature = &payload[..128];
        let signature = hex::decode(signature).expect("could not decode");
        let signature =
            libsecp256k1::Signature::parse_standard_slice(&signature).expect("could not parse");

        // parse rest of the payload and find its digest for signature
        let rest = &payload[130..];
        let digest = libsecp256k1::Message::parse(&sha256hash(rest));

        // verify signature
        Ok(libsecp256k1::verify(&digest, &signature, &public_key))
    }

    /// Decodes and parses the payload into JSON.
    ///
    /// Internally, it does three things:
    /// 1. Parse the signature (hex) and rest of the payload.
    /// 2. Verify signature with hash of the rest.
    /// 3. If pass, deserialize the rest.
    pub fn parse_signed_payload<T: for<'a> Deserialize<'a>>(
        &self,
        public_key: &PublicKey,
    ) -> Result<T, serde_json::Error> {
        // decode base64 payload
        let payload = self
            .decode_payload()
            .map_err(|err| serde_json::Error::custom(format!("Base64 decode failed: {}", err)))?;

        // parse signature (64 bytes = 128 hex chars, although the full 65-byte RSV signature is given)
        let signature = &payload[..128];
        let signature = hex::decode(signature).expect("could not decode");
        let signature =
            libsecp256k1::Signature::parse_standard_slice(&signature).expect("could not parse");

        // parse rest of the payload and find its digest for signature
        let rest = &payload[130..];
        let digest = libsecp256k1::Message::parse(&sha256hash(rest));

        // verify signature
        match libsecp256k1::verify(&digest, &signature, &public_key) {
            true => serde_json::from_slice(rest),
            false => Err(serde_json::Error::custom("Signature verification failed.")),
        }
    }

    /// A [Content Topic](https://docs.waku.org/learn/concepts/content-topics) is represented as a string with the form:
    ///
    /// ```sh
    /// /app-name/version/content-topic/encoding
    /// /waku/2/default-waku/proto # example
    /// ```
    ///
    /// `app-name` defaults to `dria` unless specified otherwise with the second argument.
    #[inline]
    pub fn create_content_topic(topic: &str) -> String {
        format!(
            "/{}/{}/{}/{}",
            WAKU_APP_NAME, WAKU_ENC_VERSION, topic, WAKU_ENCODING
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_create_content_topic() {
        let topic = "default-waku";

        let expected = "/dria/0/default-waku/proto".to_string();
        assert_eq!(WakuMessage::create_content_topic(topic), expected);
    }

    #[test]
    fn test_create_and_decode_message() {
        #[derive(Serialize, Deserialize, PartialEq, Debug)]
        struct TestStruct {
            hello: String,
        }

        let obj = TestStruct {
            hello: "world".to_string(),
        };

        let payload = serde_json::to_vec(&json!(obj)).unwrap();
        let topic = "my-content-topic";

        let message = WakuMessage::new(payload, topic);
        assert_eq!(message.payload, "eyJoZWxsbyI6IndvcmxkIn0="); // {"hello":"world"} in base64
        assert_eq!(message.content_topic, "/dria/0/my-content-topic/proto");
        assert_eq!(message.version, WAKU_ENC_VERSION, "Incorrect version.");
        assert_eq!(
            message.ephemeral, false,
            "Should not be ephemeral by default."
        );
        assert!(message.timestamp > 0);

        let parsed_obj = message.parse_payload().expect("Should decode.");
        assert_eq!(obj, parsed_obj);
    }
}
